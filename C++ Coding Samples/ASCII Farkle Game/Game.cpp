#include <iomanip>
#include <ctime>
#include <cstdlib>
#include <cstdio>
#include "Game.h"

Game::Die::Die ()
{
	// This function will: Initialize the dice. (Default constructor
	// for die).
	// Pips will hold the value randomly generated by the 
	// dice roll.
	pips = 0;
	// Whether or not the dice is selected.
	selected = false;
	// Whether or not the dice is used. 
	used = false;
}


ostream & operator << (ostream & outs, const Game::Die & D)
{
	// This function will: Output information about a single die. 
	// If the die is selected we will print it highlighted in green.
	// Otherwise it is highlighted in red. 
	char esc = 0x1B;
	outs << esc << "[0m";
	if (D.selected == true)
		outs << esc << "[7;32;43m" << D.pips << esc << "[0m";
	else
		// If the die isn't selected we print out the pips in red.
		outs << esc << "[7;31;42m" << D.pips << esc << "[0m";
	return outs;
}

void wait ()
{
	cout << "Press enter to continue\n";
	char enter;
	cin.get (enter);
	while (enter != '\n')
		cin.get (enter);
}

void sleep (float time)
{
	char command [40];
	sprintf (command, "sleep %4.2f", time);
	system (command);
}

Game::Game (const string & T) 
{
	// This function will: Set the title & use random generator.

	title = T;
	//	srand (0);
	srand (time (NULL));
}

Game::~Game ()
{
	// This function will: This is the destructor. 

}

void Game::Init ()
{
	// This function will: Initialize the game.

	gameState = GO;
	whoseTurn = NONE;
	humanOnBoard = false;
	aiaOnBoard = false;
	humanScore = 0;
	aiaScore = 0;
	lastTurn = false;
}

void Game::Instructions (ostream & outs)
{
	// This function will: Output the instructions of the game. 

	outs << endl << "Welcome to " << title << endl;
	outs << "The goal of this game is to roll dice and score as many points as possible ";
	outs << "player to first reach 10k points will be the winner. ";
	outs << endl;
	outs << endl;
	sleep (1);
}

void Game::StartTurn ()
{
	// This function will: Be called once you start your turn.
	// If the game just started or if AIA ended turn.
	if (whoseTurn == NONE || whoseTurn == AIA)
		whoseTurn = HUMAN;
	// If human ended turn.
	else
		whoseTurn = AIA;
	// Turn is obviously not done.
	turnDone = false;
	// We start with 6 die to roll.
	numToRoll = MAX_DICE;
	// Make sure the savedDice vector is empty.
	savedDice.clear ();
	subTotal = 0;
	turnTotal = 0;
	Roll();
}

ostream & operator << (ostream & outs, const Game & G)
{
	// This function will: output information with regards to the entire game. 
	// Print the game title.
	outs << G.title << '\t';
	// Informs user whether the AIA or Human is playing.
	if (G.whoseTurn == 1)
		outs << "Human playing...";
	if (G.whoseTurn == 2)
		outs << "Computer playing..";
	outs << endl;
	outs << endl;
	// Prints score for human.
	outs << "Human Score: " << G.humanScore << "; ";
	// Prints score for AIA. 
	outs << "Intelligent Agent Score: " << G.aiaScore << endl;
	outs << endl;
	outs << endl;
	// Prints out all the dice that have been saved.
	outs << "Saved Dice: ";
	for (int i = 0; i < G.savedDice.size(); i++)
		outs << G.savedDice[i] << " ";
	outs << '\t';
	// Prints the current score of the turn.
	outs << "Turn Score: " << G.subTotal << endl;
	outs << endl;
	outs << endl;
	// Prints out all the rolled dice.
	outs << "Rolled Dice: ";
	// Labels the rolled dice as letters. So player can input a letter
	// to select a die.
	char letter = 'a';
	for (int i = 0; i < G.numToRoll; i++)
	{
		outs << letter++ << " : " << G.rolledDice[i] << "  ";  
	}
	// Prints a message if there is a farkle.
	if (G.farkle == true)
		outs << "FARKLE!! Press 'r' to roll again." << endl;
	outs << endl;
	return outs;
}

bool Game::Enter (char selection, ostream & outs)
{
	// This function will: Take inputs from the user after each roll.

	switch (selection)
	{
		// Input to display the instructions.
		case 'i': Instructions (outs);
			  break;
		// Input to roll again.
		case 'r': 
			  // Saves the selected dice.
			  SaveSelected();
			  // Calculates the current score.
			  CalculateScore (savedDice);
			  Roll ();
			  break;
		// Ends turn.
		case 's': 
			  // Saves the selected dice.
			  SaveSelected();
			  // Calculates score.
			  SaveScore();
			  // Clears vector for next user.
			  savedDice.clear();
			  selectedDice.clear();
			  break;
		// Input to quit the game.
		case 'q': 
			  gameState = QUITTER;
			  turnDone = true;
			  break;
		default:
		{
			int which = selection - 'a';
			if (which < 0 || which >= rolledDice.size())
				return false;
			rolledDice[which].selected = !rolledDice[which].selected;
		}
	}
	return true;
}

bool Game::TurnDone ()
{
	// This function will: Determine whether or not the turn is done.
	
	// If statement to determine whether or not the game is done.
	if (humanScore >= 10000 or aiaScore >= 10000)
	{
		Done();
		if (humanScore > aiaScore)
			gameState = HUMANWINS;
		else if (humanScore < aiaScore)
			gameState = AIAWINS;
		else
			gameState = TIE;
	}
	return turnDone;
}


void Game::AIAPlayer (ostream & outs)
{

	// This function will: Control the AIAPlayer. 
	StartTurn();
	outs << *this;
	wait();
	// If there is a farkle, end the turn.
	if (CalculateScore(rolledDice) == 0)
		turnDone = true;
	// Keep running until AIA ends its turn.
	while (!turnDone)
	{
	// Variables to hold the number of each dice with the
	// indicated pips.
		int ones = 0;
		int twos = 0;
		int threes = 0;
		int fours = 0;
		int fives = 0;
		int sixes = 0;
		// Output the rolled dice from the AIA.
		outs << "AIA - Rolled Dice: ";
		// Determine how many die there are with each pip value.
		for (int i = 0; i < rolledDice.size(); i++)
		{
			// output the rolled dice by aia.
			outs << " " << rolledDice[i];
			if (rolledDice[i].pips == 1)
				ones++;
			if (rolledDice[i].pips == 2)
				twos++;	
			if (rolledDice[i].pips == 3)
				threes++;
			if (rolledDice[i].pips == 4)
				fours++;
			if (rolledDice[i].pips == 5)
				fives++;
			if (rolledDice[i].pips == 6)
				sixes++;
		}
		outs << endl;
		// If there is a six pack.
		if (ones == 1 && twos == 1 && threes ==1
				&& fours == 1 && fives == 1  
				&& sixes == 1)
			for (int i = 0; i< rolledDice.size(); i++)
			{
				rolledDice[i].selected = true;
				SaveSelected();
			}
		// If there is a three pair
		if (ThreePair (rolledDice) == true && numToRoll <= 3)
			for (int i = 0; i< rolledDice.size(); i++)
			{
				rolledDice[i].selected = true;
				SaveSelected();
			}
		// These prevents farkles
		if (numToRoll <= 4 and CalculateScore(rolledDice) <= 500)
			turnDone = true;
		if (numToRoll <= 3)
			for (int i = 0; i< rolledDice.size(); i++)
			{
				if (rolledDice[i].pips == 2)
					turnDone = true;
				if (rolledDice[i].pips == 3)
					turnDone = true;
				if (rolledDice[i].pips == 4)
					turnDone = true;
				if (rolledDice[i].pips == 6)
					turnDone = true;
			}
				

		// All other cases, determine whether or not to 
		// save the die based on the pip value.
		for (int i = 0; i < rolledDice.size(); i++)
		{
			if (rolledDice[i].pips == 1)
				rolledDice[i].selected = true;
			if (rolledDice[i].pips == 2)
				if (twos >= 3)
					rolledDice[i].selected = true;
			if (rolledDice[i].pips == 3)
				if (threes > 3)
					rolledDice[i].selected = true;
			if (rolledDice[i].pips == 4)
				if (fours > 3)
					rolledDice[i].selected = true;
			if (rolledDice[i].pips == 5)
			{
				if (fives < 3 && numToRoll > 3)
					rolledDice[i].selected = true;
				if (fives >= 3)
					rolledDice[i].selected = true;
			}
			if (rolledDice[i].pips == 6)
				if (sixes > 3) 
					rolledDice[i].selected = true;
		}
		// Save the selected dice.
		SaveSelected();
		// Save the score.
		SaveScore();
		// Clear saved & selected dice.
		savedDice.clear();
		selectedDice.clear();
		// Roll again.
		Roll();	
		
	}
	// Calls turn done when turn is done.
	TurnDone();
}

// Called when game is done.
bool Game::Done ()
{
	return gameState != GO;
}

void Game::Message (ostream & outs)
{
	// This function will: Print results

	string message;
	switch (gameState)
	{
		// Prints if you win.
		case HUMANWINS:
			message = "\nWinner\n"; break;
		// Prints if you lose (AIA wins).
		case AIAWINS: 
			message = "\nLoser\n"; break;
		// Prints if there is a tie.
		case TIE:
			message = "\nTie\n"; break;
		// Prints if you quit.
		case QUITTER:
			message = "\nQuitter\n"; break;
	}
	// Prints out the Human & AIA score.
	outs << "\nHuman Score is: " << humanScore << endl;
	outs << "\nAIA Player Score is: " << aiaScore << endl;
	outs << message << endl;
}

void Game::Roll ()
{
	// Set farkle to false at the beginning.
	farkle = false;
	// This function will: Generate the rolled dice pips/values.
	// Rings bell.
	cout << '\a';	
	// Make sure there is nothing in the vector before roll.
	rolledDice.clear();
	// Roll the number of dice needed.
	for (int i = 0; i < numToRoll; i++)
	{
		// Create a new die.
		Die die;
		// Pip value will be randomly generated between (1-6).
		int value = 0;
		value = rand();
		value = (value % 6) + 1;
		die.pips = value;
		// Die is not selected or used.
		die.selected = false;
		die.used = false;
		// Put rolled die into rolled vector.
		rolledDice.push_back(die);
	}		
	// Determine if there is a farkle.
	if (CalculateScore(rolledDice) == 0)
	{
		farkle = true;
		// You lose all your points if you farkle.
		subTotal = 0;
		// Your turn has ended if you get a 
		// farkle. 
		turnDone == true;
		Enter ('s', cout);
	}
}

// Function will test for three-pairs with the AIA player.
bool Game::ThreePair (vector <Die> dice)
{
	// Variables to hold the number of each pip rolled.
	int ones = 0;
	int twos = 0;
	int threes = 0;
	int fours = 0;
	int fives = 0;
	int sixes = 0;
	int pairs = 0;
	// Analyze the dice.
	for (int i = 0; i< dice.size(); i++)
	{
		if (dice[i].pips == 1)
			ones++;
		if (dice[i].pips == 2)
			twos++;
		if (dice[i].pips == 3)
			threes++;
		if (dice[i].pips == 4)
			fours++;
		if (dice[i].pips == 5)
			fives++;
		if (dice[i].pips == 6)
			sixes++;
	}
	// Determine pairs (two of the same die pips).
	if (ones == 2)
		pairs++;
	if (twos == 2)
		pairs++;
	if (threes == 2)
		pairs++;
	if (fours == 2)
		pairs++;
	if (fives == 2)
		pairs++;
	if (sixes == 2)
		pairs++;
	// There is a three pair if there are three pairs.
	if (pairs == 3)
		return true;
}

// Function to calculate score. 
int Game::CalculateScore (vector <Die> & dice)
{
	static int points [7][7] = {{0,   0,   0,    0,    0,    0,    0}, 
		{0, 100, 200, 1000, 2000, 4000, 8000},
		{0,   0,   0,  200,  400,  800, 1600},
		{0,   0,   0,  300,  600, 1200, 2400},
		{0,   0,   0,  400,  800, 1600, 3200},
		{0,  50, 100,  500, 1000, 2000, 4000},
		{0,   0,   0,  600, 1200, 2400, 4800}};

	int counts [7] = {0, 0, 0, 0, 0, 0, 0};
	for (int i = 0; i < dice.size(); i++)
		counts[dice[i].pips]++;
	int ones = 0, twos = 0;
	int score = 0;
	for (int i = 1; i <= 6; i++)
	{
		if (counts[i] == 1)
			ones++;
		if (counts[i] == 2)
			twos++;
		int pts = points[i][counts[i]];
		if (pts > 0)
			for (int j = 0; j < dice.size(); j++)
				if (dice[j].pips == i)
					dice[j].used = true; 
		score += pts;
	}
	if (ones == 6 || twos == 3)
		for (int j = 0; j < dice.size(); j++)
			dice[j].used = true;; 
	if (ones == 6)
		score = 1000;
	else if (twos == 3)
		score = 500;
	return score;
}

void Game::SaveSelected ()
{
	// Save the selected dice.
	for (int i = 0; i < numToRoll; i++)
	{
		// Save the dice that are selected.
		if (rolledDice[i].selected == true)
		{
			// Dice becomes used.
			rolledDice[i].used = true;
			// Add the selected/saved dice to their
			// respective vectors.
			selectedDice.push_back(rolledDice[i]);
			savedDice.push_back(rolledDice[i]);
		}
		else
			// If dice is not used then it is remaining.
			remainingDice.push_back(rolledDice[i]);

	}
	// Determine the number to roll remaining.
	if (remainingDice.size() == 0)
		numToRoll = 6;
	else
		numToRoll = remainingDice.size();
	// Calculate the score of the saved dice &
	// stores it in subTotal.
	subTotal += CalculateScore (selectedDice);
	// Clear rolled dice vectors.
	rolledDice.clear();
	remainingDice.clear();
	selectedDice.clear();
}

// Function saves the score for the current player.
void Game::SaveScore ()
{
	// If player was playing...
	if (whoseTurn == 1)
		// Save score.
		humanScore += subTotal;
	// If computer was playing...
	if (whoseTurn == 2)
		// Save score...
		aiaScore += subTotal;
	// End of turn. 			
	turnDone = true;

}
